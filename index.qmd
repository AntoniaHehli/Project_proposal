---
title: The title of your Semesterproject
subtitle: A subtle subtitle
author: Laura Haus and Antonia Hehli
output: html
---

<!-- You can add  your R Code with Code chunks-->

```{r}
#| echo: false
#| warning: false
#| message: false

# You can set chunk options individually per code chunk, as was done with this
# code chunk.

# echo: false           hides the code from the generated output
# warning: false        hides warnings from the generated output
# message: false        hides messages from the generated output

# To apply the setting for all code chunks, add the options to the yaml header of the document (in between the ---) without the preceeding "#|".

```

## Settings

```{r}
# import libraries
library("dplyr")
library("ggplot2")
library("readr")
library("raster")
library("sf")
library("terra")
library("lubridate")
```

## Abstract

## Introduction

Road transportation is responsible for around 20 percent of global carbon dioxide emission whereof almost half of these emissions are caused by passenger road vehicles (Suarez et al., 2022). Due to the strongly negative impact of carbon dioxide emissions on climate change, they world widely receive gradually increasing concern (Dong et al., 2022). Driving behavior like acceleration as well as terrain characteristics such as an incline have valid impacts on carbon dioxide emissions (Dong et al., 2022; Suarez et al., 2022; Xu et al., 2022).

However, road traffic is not the only type of traffic that causes carbon dioxide emissions. Trains, trams, and – when also taking production emissions into account – even bicycles cause carbon dioxide emissions. Therefore, we will also take these transportation modes into account.
In this project, we analyze carbon dioxide emissions by different transportation types using different complexity levels as well as emission scenarios and compare these different setups with each other. We use validated movement data collected by the Posmo app from XY students of the course Computational Movement Analysis in Spring 2023 at ZHAW.

```{r}
library(ggplot2)

# Include tables with the function "kable"

knitr::kable(head(mtcars))
```

```{r}
# include plots automatically

ggplot(mtcars, aes(cyl, disp)) +
  geom_point()

```

## Material and Methods

### Preprocessing

```{r function loadPosmoData}
# define a function to load the posmo data

loadPosmoData <- function(filepath){
  read_delim(filepath, delim = ",") |>
    
    # we do not need the place name
    subset(select = -c(place_name)) |>
    
    # remove NA values for transport mode, we need a specified transport mode
    filter(!is.na(transport_mode))
  }

```

```{r load validated data}
# load all validated Posmo track files
#posmo <- loadPosmoData("data/posmo_tracks/posmo_2023-04-05T00_00_00+02_00-2023-06-11T23_59_59+02_00.csv")
posmo <- loadPosmoData("data/posmo_tracks/posmo.csv")

# remove rows with NA in the coordinates
posmo <- posmo[!is.na(posmo$lon_x), ]

# convert to sf object
posmo <- st_as_sf(posmo, coords = c("lon_x", "lat_y"), crs = 4326) |>
  st_transform(2056)

# extract coordinates
posmo_coord <- st_coordinates(posmo)

# create one dataframe
posmo <- cbind(posmo, posmo_coord)
```


```{r use function loadPosmoData and join data frames}
# load all Posmo track files
posmo <- loadPosmoData("data/posmo_tracks/posmo.csv")
posmo1 <- loadPosmoData("data/posmo_tracks/posmo_1.csv")
posmo2 <- loadPosmoData("data/posmo_tracks/posmo_2.csv")
posmo3 <- loadPosmoData("data/posmo_tracks/posmo_3.csv")
posmo4 <- loadPosmoData("data/posmo_tracks/posmo_4.csv")
posmo5 <- loadPosmoData("data/posmo_tracks/posmo_5.csv")
posmo6 <- loadPosmoData("data/posmo_tracks/posmo_6.csv")

# join the data frames together
posmo_joined <- full_join(posmo, posmo1)
posmo_joined <- full_join(posmo_joined, posmo2)
posmo_joined <- full_join(posmo_joined, posmo3)
posmo_joined <- full_join(posmo_joined, posmo4)
posmo_joined <- full_join(posmo_joined, posmo5)

# make the last join and convert to a sf object
posmo_joined <- full_join(posmo_joined, posmo6) |>
  st_as_sf(coords = c("lon_x", "lat_y"), crs = 4326)
```

#### Filter transport modes

We only need transportation modes that generate carbon dioxide emissions. Namely, these are car, bus, train, airplane and tram. Therefore, we exclude all other transportation modes.

```{r filter transportation modes}
# get all the transportation modes
unique(posmo_joined$transport_mode)

# save transportation modes we need in a vector
transport_modes = c("Car", "Bus", "Train", "Tram", "Airplane", "Bike", "E_Bike")

# filter to only the transportation modes we need
posmo_filter <- posmo_joined |>
  filter(transport_mode %in% transport_modes)
```

Now, all the tracks with a transportation mode that causes carbon emissions are imported. In a next step, we plot the tracks to get an overview over them.

```{r plot all tracks}
# plot the tracks
ggplot(posmo_filter, aes(color = transport_mode)) + 
  geom_sf()
```

#### Filter segment locations

As is visible in the figure, there are not only data points within Switzerland, but also outside. Therefore, we cut our extent down to only Switzerland. The polygons of Switzerland and of the cantons were downloaded from swisstopo as a geodatabase (.gdb) and preprocessed in QGIS. We excluded Liechtenstein from the Swiss boundaries and converted Switzerland's border as well as the cantons to a geopackage (.gpkg).

```{r filter Posmo tracks to CH and ZH}
# read Switzerland and the cantons
CH_boundaries <- st_read("data/swissboundaries3D/CH_boundaries.gpkg", crs = 2056)
CH_cantons <- st_read("data/swissboundaries3D/CH_cantons.gpkg", crs = 2056)

# filter Zurich
zurich <- CH_cantons |> 
  filter(NAME == "Zürich")

# transform the coordinate system to the Swiss crs to intersect with boundaries
posmo_filter <- posmo_filter |>
  st_transform(crs = 2056)

# get only the coordinates of the transformed Posmo data
posmo_coord <- st_coordinates(posmo_filter)

# append the single X and Y value to the sf object
posmo_filter$X <- posmo_coord[,1]
posmo_filter$Y <- posmo_coord[,2]

# filter points that are within Switzerland
posmo_CH <- st_filter(posmo_filter, CH_boundaries)

# check if it worked (Switzerland)
ggplot(posmo_CH, aes(color = transport_mode)) + 
  geom_sf() +
  coord_sf(datum = st_crs(2056))+
  labs(x = "E",
       y = "N",
       title = "Posmo tracks in Switzerland")

# filter points that are within Zurich
posmo_ZH <- st_filter(posmo_filter, zurich)

# check if it worked (Zurich)
ggplot(posmo_ZH, aes(color = transport_mode)) + 
  geom_sf() +
  coord_sf(datum = st_crs(2056))+
  labs(x = "E",
       y = "N",
       title = "Posmo tracks in the canton of Zurich")
```

#### Filter static points

```{r}
# functions to determine moving window
movingWindowLag <- function(E, N, n){
  sqrt((lag(E, n) - E)^2 + (lag(N, n) - N)^2)
}

movingWindowLead <- function(E, N, n){
  sqrt((E - lead(E, n))^2 + (N - lead(N, n))^2)
}
```

```{r}
# calculate moving window
posmo <- posmo |>
  mutate(
    minus3 = movingWindowLag(X, Y, 3),
    minus2 = movingWindowLag(X, Y, 2),
    minus1 = movingWindowLag(X, Y, 1),
    plus1 = movingWindowLead(X, Y, 1),
    plus2 = movingWindowLead(X, Y, 2),
    plus3 = movingWindowLead(X, Y, 3)
  )

posmo <- posmo |>
  rowwise() |>
  mutate(
    stepMean = mean(c(minus3, minus2, minus1, plus1, plus2, plus3))
  ) |>
  ungroup()

posmo <- posmo |>
    ungroup() |>
    mutate(static = stepMean < 50)
```

```{r}
summary(posmo)

posmo |>
  ggplot(aes(X,Y)) +
  geom_point(aes(colour = static)) +
  geom_path() +
  coord_fixed()

posmo <- posmo |>
    filter(!static)
```

#### DHM

The .asc file of the DHM25 was converted to a .tif file in QGIS before loading it here.

```{r read DHM}
dhm25 <- terra::rast("data/DHM25/dhm_25.tif")
```

### First analysis

In the first step of the analysis we use a constant value to define the carbon dioxide emissions of all the Posmo tracks. These constants are defined below.

```{r constants for emissions}
# for plane [g/km]
c_plane <- 200

# for cars: we have various sources, therefore, we take a mean value [g/km]
c_car <- c(130, 162, 122.3, 200) |> 
  mean()

# for buses
c_bus <- c(42, 108, 88.7, 25.15) |>
  mean()

# for trains
c_train <- c(93, 110.9) |>
  mean()

# for trams
c_tram <- c(80, 37) |>
  mean()

# for e-bikes
c_ebike <- 14

# for bikes
c_bike <- 8
```

```{r function to get the number of days per user}
# define a function to get the number of weekdays recorded per user id
get_days <- function(user, posmo_data){
  # filter the user
  posmo_user <- posmo_data |>
    filter(user_id == user)
  
  # convert the datetime format to days and get the unique days
  recorded_days <- unique(as.Date(posmo_user$datetime, format = "%d"))
  
  # return the number of unique days
  return(length(recorded_days))
}
```


#### Trajectories within the canton of Zurich

```{r number of days per user ZH}
# save the unique user_ids in the data set
posmo_ZH_userids <- unique(posmo_ZH$user_id) 

# make an empty data frame with the number of days per users
posmo_ZH_days_per_user <- data.frame(user_id = posmo_ZH_userids)

# create an empty vector to append
number_of_days = c()

# use the created function
for (i in posmo_ZH_userids){
  day = get_days(i, posmo_ZH)
  number_of_days <- append(number_of_days, day)
}

# add the number of days to the user_id
posmo_ZH_days_per_user$days <- number_of_days
```

We can now sum the length [km] per transportation medium and person to get an idea about their carbon dioxide emissions. Because the different users recorded a different amount of days, we divide the emissions by the number of days. Therefore, we get the average daily emissions per user.

```{r calculate emissions ZH}
# calculate the distances [m], the timelag [s], the speed [m/s], and the speek [km/h]: use group_by to make sure it only calculates for one user id and not between different user ids
posmo_ZH <- posmo_ZH |>
  group_by(user_id)|>
  mutate(
    distance_m = sqrt((lead(X, 1) - X)^2 + (lead(Y, 1) - Y)^2),
    distance_km = distance_m/1000,
    timelag_s = as.integer(difftime(lead(datetime), datetime),
                           units = "secs"),
    speed_ms = (distance_m/timelag_s),
    speed_kmh = (speed_ms*3.6)
    ) |>
  ungroup()

# remove NA distance values
posmo_ZH <- posmo_ZH |> 
  filter(!is.na(distance_km))

# group by user_id and transport_mode and sum up the distance in km
posmo_ZH_traveldistance <- 
  posmo_ZH |> 
  group_by(user_id, transport_mode) |>
  summarise(sum_km = sum(distance_km))

# create a look-up table for the different emission constants
constants_table <- data.frame(
  transport_mode = c("Airplane", "Bike", "Bus", "Car", "E_Bike", "Train", "Tram"),
  constant_gkm = c(c_plane, c_bike, c_bus, c_car, c_ebike, c_train, c_tram),
  stringsAsFactors = FALSE
)

# join the lookup table to the initial data frame
posmo_ZH_traveldistance <- posmo_ZH_traveldistance |> 
  left_join(constants_table, by = "transport_mode")

# join the numebr of recording days to the data frame
posmo_ZH_traveldistance <- posmo_ZH_traveldistance |> 
  left_join(posmo_ZH_days_per_user, by = "user_id")

# multiply the CO2 emissions constant with the traveled distance and divide by the number of recorded days
posmo_ZH_traveldistance <- posmo_ZH_traveldistance |>
  mutate(co2_emissions_g = sum_km * constant_gkm,
         co2_emissions_g_per_d = co2_emissions_g/days)

```

We create a bar chart to have an overview.

```{r total emission ZH}
# calculate the total emissions by user ID and transportation mode
emissions_ZH <- aggregate(co2_emissions_g_per_d ~ user_id + transport_mode, posmo_ZH_traveldistance, sum)

# create the bar chart
ggplot(emissions_ZH, aes(x = user_id, y = co2_emissions_g_per_d, fill = transport_mode)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "Users", y = "Total Emissions [g/day]", fill = "Transport Mode",
       subtitle = "Movement trajectories within the canton of Zurich") +
  ggtitle("Total Emissions by User ID and Transportation Mode per Day") +
  theme_minimal()+
  theme(axis.text.x = element_blank())
```

#### Trajectories in Switzerland

```{r number of days per user CH}
# save the unique user_ids in the data set
posmo_CH_userids <- unique(posmo_CH$user_id) 

# make an empty data frame with the number of days per users
posmo_CH_days_per_user <- data.frame(user_id = posmo_CH_userids)

# create an empty vector to append
number_of_days = c()

# use the created function
for (i in posmo_CH_userids){
  day = get_days(i, posmo_CH)
  number_of_days <- append(number_of_days, day)
}

# add the number of days to the user_id
posmo_CH_days_per_user$days <- number_of_days
```

We can now sum the length [km] per transportation medium and person to get an idea about their carbon dioxide emissions. Because the different users recorded a different amount of days, we divide the emissions by the number of days. Therefore, we get the average daily emissions per user.

```{r calculate emissions CH}
# calculate the distances [m], the timelag [s], the speed [m/s], and the speek [km/h]: use group_by to make sure it only calculates for one user id and not between different user ids
posmo_CH <- posmo_CH |>
  group_by(user_id)|>
  mutate(
    distance_m = sqrt((lead(X, 1) - X)^2 + (lead(Y, 1) - Y)^2),
    distance_km = distance_m/1000,
    timelag_s = as.integer(difftime(lead(datetime), datetime),
                           units = "secs"),
    speed_ms = (distance_m/timelag_s),
    speed_kmh = (speed_ms*3.6)
    ) |>
  ungroup()

# remove NA distance values
posmo_CH <- posmo_CH |> 
  filter(!is.na(distance_km))

# group by user_id and transport_mode and sum up the distance in km
posmo_CH_traveldistance <- 
  posmo_CH |> 
  group_by(user_id, transport_mode) |>
  summarise(sum_km = sum(distance_km))

# join the lookup table to the initial data frame
posmo_CH_traveldistance <- posmo_CH_traveldistance |> 
  left_join(constants_table, by = "transport_mode")

# join the number of recording days to the data frame
posmo_CH_traveldistance <- posmo_CH_traveldistance |> 
  left_join(posmo_CH_days_per_user, by = "user_id")

# multiply the CO2 emissions constant with the traveled distance and divide by the number of recorded days
posmo_CH_traveldistance <- posmo_CH_traveldistance |>
  mutate(co2_emissions_g = sum_km * constant_gkm,
         co2_emissions_g_per_d = co2_emissions_g/days)

```

We create a bar chart to have an overview.

```{r total emissions CH}
# calculate the total emissions by user ID and transportation mode
emissions_CH <- aggregate(co2_emissions_g_per_d ~ user_id + transport_mode, posmo_CH_traveldistance, sum)

# create the bar chart
ggplot(emissions_CH, aes(x = user_id, y = co2_emissions_g_per_d, fill = transport_mode)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "Users", y = "Total Emissions [g/day]", fill = "Transport Mode",
       subtitle = "Movement trajectories in Switzerland") +
  ggtitle("Total Emissions by User ID and Transportation Mode per Day") +
  theme_minimal()+
  theme(axis.text.x = element_blank())
```

We also plot the first results.

```{r plot emissions CH and ZH}
# for all of Switzerland
ggplot() + 
  geom_sf(data = CH_cantons, aes(alpha = 100)) +
  geom_sf(data = posmo_CH_traveldistance, aes(color = co2_emissions_g_per_d))+
  labs(title = "Total Emissions per Transport Mode and User",
     subtitle = "Movement trajectories in Switzerland",
     x = "E",
     y = "N")+
  scale_color_continuous(name = "CO2 emissions [g/day]")+
  scale_alpha_continuous(guide = "none") +
  coord_sf(datum = st_crs(2056))

# for Zurich
ggplot() + 
  geom_sf(data = zurich, aes(alpha = 100)) +
  geom_sf(data = posmo_ZH_traveldistance, aes(color = co2_emissions_g_per_d))+
  labs(title = "Total Emissions per Transport Mode and User",
     subtitle = "Movement trajectories in the Canton of Zurich",
     x = "E",
     y = "N")+
  scale_color_continuous(name = "CO2 emissions [g/day]", type = "viridis")+
  scale_alpha_continuous(guide = "none") +
  coord_sf(datum = st_crs(2056))+
  theme_minimal()

```


```{r function to get the weekly emissions}
# define a function to get the number of weekdays recorded per user id
weekly_emissions <- function(posmo_data, constants){
  #make sure Date is provided as date and not as datetime
  posmo_data$week <- isoweek(as.Date(posmo_data$datetime))
  weekly_distance <- aggregate(distance_km ~ user_id + week + transport_mode, posmo_data, FUN = sum)
  weekly_emission <- weekly_distance |>
    left_join(constants, by = "transport_mode")
  weekly_emission <- weekly_emission |>
    mutate(
      co2_emission = distance_km * constant_gkm
    )
  return(weekly_emission)
}

weekly_emission_zh <- weekly_emissions(posmo_ZH, constants_table)

# ist das selbe wie über alles gemittelt
#weekly_emission_zh_mean <- aggregate(constant_gkm ~ user_id, weekly_emission_zh, FUN = mean)

```

## Results

## Discussion

## Sources

*Dong, Yaping; Xu, Jinliang; Ni, Jie* (2022): Carbon emission model of vehicles driving at fluctuating speed on highway. In: Environmental Science and Pollution Research, Vol. 30, pp. 18064-18077.

*Suarez, Jaime; Makridis, Michail; Anesiadou, Aikaterini; Komnos, Dimitrios; Ciuffo, Biagio; Fontaras, Georgios* (2022): Benchmarking the driver acceleration impact on vehicle energy consumption and CO2 emissions. In: Transportation Research Part D, Vol. 107.

*Xu, Jinliang; Dong, Yaping & Yan, Menghua* (2020): A Model for Estimating Passenger-Car Carbon Emissions that Accounts for Uphill, Downhill and Flat Roads. In: Sustainability, Vol. 12, No. 2028.

