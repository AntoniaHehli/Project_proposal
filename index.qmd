---
title: The title of your Semesterproject
subtitle: A subtle subtitle
author: Laura Haus and Antonia Hehli
output: html
---

<!-- You can add  your R Code with Code chunks-->

```{r}
#| echo: false
#| warning: false
#| message: false

# You can set chunk options individually per code chunk, as was done with this
# code chunk.

# echo: false           hides the code from the generated output
# warning: false        hides warnings from the generated output
# message: false        hides messages from the generated output

# To apply the setting for all code chunks, add the options to the yaml header of the document (in between the ---) without the preceeding "#|".

```

## Settings

```{r}
# import libraries
library("dplyr")
library("ggplot2")
library("readr")
library("raster")
library("sf")
library("terra")

```

## Abstract

## Introduction

```{r}
library(ggplot2)

# Include tables with the function "kable"

knitr::kable(head(mtcars))
```

```{r}
# include plots automatically

ggplot(mtcars, aes(cyl, disp)) +
  geom_point()

```

## Material and Methods

### Preprocessing

```{r function loadPosmoData}
# define a function to load the posmo data

loadPosmoData <- function(filepath){
  read_delim(filepath, delim = ",") |>
    
    # we do not need the place name
    subset(select = -c(place_name)) |>
    
    # remove NA values for transport mode, we need a specified transport mode
    filter(!is.na(transport_mode))
  }

```

```{r use function loadPosmoData and join data frames}
# load all Posmo track files
posmo <- loadPosmoData("data/posmo_tracks/posmo.csv")
posmo1 <- loadPosmoData("data/posmo_tracks/posmo_1.csv")
posmo2 <- loadPosmoData("data/posmo_tracks/posmo_2.csv")
posmo3 <- loadPosmoData("data/posmo_tracks/posmo_3.csv")
posmo4 <- loadPosmoData("data/posmo_tracks/posmo_4.csv")
posmo5 <- loadPosmoData("data/posmo_tracks/posmo_5.csv")
posmo6 <- loadPosmoData("data/posmo_tracks/posmo_6.csv")

# join the data frames together
posmo_joined <- full_join(posmo, posmo1)
posmo_joined <- full_join(posmo_joined, posmo2)
posmo_joined <- full_join(posmo_joined, posmo3)
posmo_joined <- full_join(posmo_joined, posmo4)
posmo_joined <- full_join(posmo_joined, posmo5)

# make the last join and convert to a sf object
posmo_joined <- full_join(posmo_joined, posmo6) |>
  st_as_sf(coords = c("lon_x", "lat_y"), crs = 4326)
```

#### Filter transport modes

We only need transportation modes that generate carbon dioxide emissions. Namely, these are car, bus, train, airplane and tram. Therefore, we exclude all other transportation modes.

```{r filter transportation modes}
# get all the transportation modes
unique(posmo_joined$transport_mode)

# save transportation modes we need in a vector
transport_modes = c("Car", "Bus", "Train", "Tram", "Airplane", "Bike", "E_Bike")

# filter to only the transportation modes we need
posmo_filter <- posmo_joined |>
  filter(transport_mode %in% transport_modes)
```

Now, all the tracks with a transportation mode that causes carbon emissions are imported. In a next step, we plot the tracks to get an overview over them.

```{r plot all tracks}
# plot the tracks
ggplot(posmo_filter, aes(color = transport_mode)) + 
  geom_sf()
```

#### Filter segment lcoations

As is visible in the figure, there are not only data points within Switzerland, but also outside. Therefore, we cut our extent down to only Switzerland. The polygons of Switzerland and of the cantons were downloaded from swisstopo as a geodatabase (.gdb) and preprocessed in QGIS. We excluded Liechtenstein from the Swiss boundaries and converted Switzerland's border as well as the cantons to a geopackage (.gpkg).

```{r filter Posmo tracks to CH and ZH}
# read Switzerland and the cantons
CH_boundaries <- st_read("data/swissboundaries3D/CH_boundaries.gpkg", crs = 2056)
CH_cantons <- st_read("data/swissboundaries3D/CH_cantons.gpkg", crs = 2056)

# filter Zurich
zurich <- CH_cantons |> 
  filter(NAME == "ZÃ¼rich")

# transform the coordinate system to the Swiss crs to intersect with boundaries
posmo_filter <- posmo_filter |>
  st_transform(crs = 2056)

# get only the coordinates of the transformed Posmo data
posmo_coord <- st_coordinates(posmo_filter)

# append the single X and Y value to the sf object
posmo_filter$X <- posmo_coord[,1]
posmo_filter$Y <- posmo_coord[,2]

# filter points that are within Switzerland
posmo_CH <- st_filter(posmo_filter, CH_boundaries)

# check if it worked (Switzerland)
ggplot(posmo_CH, aes(color = transport_mode)) + 
  geom_sf() +
  coord_sf(datum = st_crs(2056))+
  labs(x = "E",
       y = "N",
       title = "Posmo tracks in Switzerland")

# filter points that are within Zurich
posmo_ZH <- st_filter(posmo_filter, zurich)

# check if it worked (Zurich)
ggplot(posmo_ZH, aes(color = transport_mode)) + 
  geom_sf() +
  coord_sf(datum = st_crs(2056))+
  labs(x = "E",
       y = "N",
       title = "Posmo tracks in the canton of Zurich")
```

#### DHM

The .asc file of the DHM25 was converted to a .tif file in QGIS before loading it here.

```{r read DHM}
dhm25 <- rast("data/DHM25/dhm_25.tif")
```

### First analysis

In the first step of the analysis we use a constant value to define the carbon dioxide emissions of all the Posmo tracks. These constants are defined below.

```{r constants for emissions}
# for plane [g/km]
c_plane <- 200

# for cars: we have various sources, therefore, we take a mean value [g/km]
c_car <- c(130, 162, 122.3, 200) |> 
  mean()

# for buses
c_bus <- c(42, 108, 88.7, 25.15) |>
  mean()

# for trains
c_train <- c(93, 110.9) |>
  mean()

# for trams
c_tram <- c(80, 37) |>
  mean()

# for e-bikes
c_ebike <- 14

# for bikes
c_bike <- 8
```

We can now sum the length [km] per transportation medium and person to get an idea about their carbon dioxide emissions.

```{r calculate emissions}
# calculate the distances [m], the timelag [s], the speed [m/s], and the speek [km/h]: use group_by to make sure it only calculates for one user id and not between different user ids
posmo_ZH <- posmo_ZH |>
  group_by(user_id)|>
  mutate(
    distance_m = sqrt((lead(X, 1) - X)^2 + (lead(Y, 1) - Y)^2),
    distance_km = distance_m/1000,
    timelag_s = as.integer(difftime(lead(datetime), datetime),
                           units = "secs"),
    speed_ms = (distance_m/timelag_s),
    speed_kmh = (speed_ms*3.6)
    ) |>
  ungroup()

# remove NA distance values
posmo_ZH <- posmo_ZH |> 
  filter(!is.na(distance_km))

# group by user_id and transport_mode and sum up the distance in km
posmo_ZH_traveldistance <- 
  posmo_ZH |> 
  group_by(user_id, transport_mode) |>
  summarise(sum_km = sum(distance_km))

# create a look-up table for the different emission constants
constants_table <- data.frame(
  transport_mode = c("Airplane", "Bike", "Bus", "Car", "E_Bike", "Train", "Tram"),
  constant_gkm = c(c_plane, c_bike, c_bus, c_car, c_ebike, c_train, c_tram),
  stringsAsFactors = FALSE
)

# join the lookup table to the initial data frame
posmo_ZH_traveldistance <- posmo_ZH_traveldistance |> 
  left_join(constants_table, by = "transport_mode")

# multiply the CO2 emissions constant with the travelled distance
posmo_ZH_traveldistance <- posmo_ZH_traveldistance |>
  mutate(co2_emissions_g = sum_km * constant_gkm)

```



## Results

## Discussion
